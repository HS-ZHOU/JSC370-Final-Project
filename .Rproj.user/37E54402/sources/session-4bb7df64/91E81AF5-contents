---
title: "Lab 11 - Interactive Visualization"
author: "Hongshuo Zhou"
output: 
  rmdformats::robobook
  # tufte::tufte_html:
  #   css: style.css
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE,
  eval = TRUE,
  echo = TRUE,
  cache = FALSE,
  include = TRUE,
  fig.width = 7, 
  fig.align = 'center',
  fig.asp = 0.618,
  out.width = "700px")
```

# Learning Goals

- Read in and process the COVID dataset from the New York Times GitHub repository
- Create interactive graphs of different types using `plot_ly()` and `ggplotly()` functions
- Customize the hoverinfo and other plot features
- Create a Choropleth map using `plot_geo()`

# Lab Description

We will work with COVID data downloaded from the New York Times. The dataset consists of COVID-19 cases and deaths in each US state during the course of the COVID epidemic.

**The objective of this lab is to explore relationships between cases, deaths, and population sizes of US states, and plot data to demonstrate this**

# Steps

## I. Reading and processing the New York Times (NYT) state-level COVID-19 data

### 0. Install and load libraries

```{r message=TRUE, echo=TRUE, warning=TRUE}
# install.packages("widgetframe")
library(data.table)
library(tidyverse)
library(plotly)
library(knitr)
library(widgetframe)
```

### 1. Read in the data

- Read in the COVID data with data.table:fread() from the NYT GitHub repository: "https://raw.githubusercontent.com/nytimes/covid-19-data/master/us-states.csv"
- Read in the state population data with data.table:fread() from the repository: "https://raw.githubusercontent.com/COVID19Tracking/associated-data/master/us_census_data/us_census_2018_population_estimates_states.csv""
- Merge datasets

```{r}
cv_states_readin <- 
  data.table::fread("https://raw.githubusercontent.com/nytimes/covid-19-data/master/us-states.csv")


state_pops <- data.table::fread("https://raw.githubusercontent.com/COVID19Tracking/associated-data/master/us_census_data/us_census_2018_population_estimates_states.csv")

state_pops$abb <- state_pops$state
state_pops$state <- state_pops$state_name
state_pops$state_name <- NULL

cv_states <- merge(cv_states_readin, state_pops, by="state")
```

### 2. Look at the data

- Inspect the dimensions, `head`, and `tail` of the data
- Inspect the structure of each variables. Are they in the correct format?

```{r eval=FALSE}
dim(cv_states)
head(cv_states)
tail(cv_states)
str(cv_states)
glimpse(cv_states)
```

### 3. Format the data

- Make date into a date variable
- Make state into a factor variable
- Order the data first by state, second by date
- Confirm the variables are now correctly formatted
- Inspect the range values for each variable. What is the date range? The range of cases and deaths?

```{r}
cv_states$date <- as.Date(cv_states$date, format="%Y-%m-%d")


state_list <- unique(cv_states$state)
cv_states$state <- factor(cv_states$state, levels = state_list)
abb_list <- unique(cv_states$abb)
cv_states$abb <- factor(cv_states$abb, levels = abb_list)


cv_states <- cv_states[order(cv_states$state, cv_states$date),]
```

```{r eval=FALSE}
str(cv_states)
head(cv_states)
tail(cv_states)


head(cv_states)
summary(cv_states)
min(cv_states$date)
max(cv_states$date)
```

### 4. Add `new_cases` and `new_deaths` and correct outliers

- Add variables for new cases, `new_cases`, and new deaths, `new_deaths`: 
  - Hint: You can set `new_cases` equal to the difference between cases on date i and date i-1, starting on date i=2
  
```{r}
cv_states <- cv_states |>
  group_by(state) |> 
  mutate(
    new_cases = c(-999999, diff(cases)),
    new_deaths = c(-999999, diff(deaths))
  ) |>
  mutate(new_cases = ifelse(new_cases == -999999, cases, new_cases),
         new_deaths = ifelse(new_deaths == -999999, deaths, new_deaths))
```
  
- Filter to dates after October 1, 2022


```{r}
cv_states <- cv_states |>
  dplyr::filter(date >= "2022-10-01")
```

- Use `ggplotly` for EDA: See if there are outliers or values that don't make sense for `new_cases` and `new_deaths`. Which states and which dates have strange values?


```{r}
plt_cases <- ggplot(cv_states,
                  aes(x=date, y=new_cases, color = state)) +
  geom_line() +
  theme_minimal() +
  ggtitle("New cases since 2022-10-01")

ggplotly(plt_cases)

```

```{r}
plt_deaths <- ggplot(cv_states,
                  aes(x=date, y=new_deaths, color = state)) +
  geom_line() +
  theme_minimal() +
  ggtitle("New deaths since 2022-10-01")

ggplotly(plt_deaths)

```

_Comment: In previous two plots, we can see that there are negative values exist in both of them. Since the numbers represent the daily new cases and daily new deaths, negative values don't make sense within the context. For instance, daily new cases in Texas on 2022-10-08 is -11187 and daily new deaths in Colorado on 2022-11-16 is -198. In addition, Taxas on 2023-03-15 has the highest daily new cases and New York on 2022-11-11 has the highest daily new deaths, which are outliers as well._


- Correct outliers: Set negative values for `new_cases` or `new_deaths` to 0

```{r}
cv_states <- cv_states |>
  mutate(
    new_cases = ifelse(new_cases < 0, 0, new_cases),
    new_deaths = ifelse(new_deaths < 0, 0, new_deaths)
  )
```


- Inspect data again interactively

```{r}
plt_cases <- ggplot(cv_states,
                  aes(x=date, y=new_cases, color = state)) +
  geom_line() +
  theme_minimal() +
  ggtitle("New cases since 2022-10-01")

ggplotly(plt_cases)



plt_deaths <- ggplot(cv_states,
                  aes(x=date, y=new_deaths, color = state)) +
  geom_line() +
  theme_minimal() +
  ggtitle("New deaths since 2022-10-01")

ggplotly(plt_deaths)

```

### 5. Add additional variables

- Add population-normalized (by 100,000) variables for each variable type (rounded to 1 decimal place). Make sure the variables you calculate are in the correct format (`numeric`). You can use the following variable names:
  - `per100k` = cases per 100,000 population
  - `newper100k`= new cases per 100,000
  - `deathsper100k` = deaths per 100,000
  - `newdeathsper100k` = new deaths per 100,000
  
  
```{r}

cv_states <- cv_states |>  
  mutate(
    per100k = round(cases / population * 1e5, digits = 1),
    newper100k = round(new_cases / population * 1e5, digits = 1),
    deathsper100k = round(deaths / population * 1e5, digits = 1),
    newdeathsper100k = round(new_deaths / population * 1e5, digits = 1)
  )

cv_states |> 
  select(per100k, newper100k, deathsper100k, newdeathsper100k) |> 
  summary()

```

- Add a "naive CFR" variable representing `deaths / cases` on each date for each state

```{r}
cv_states <- cv_states |> 
  mutate(naive_cfr = deaths / cases)
```


- Create a dataframe representing values on the most recent date, `cv_states_today`

```{r}
max_date <- max(cv_states$date)
cv_states_today <- cv_states |> 
  dplyr::filter(date == max_date)
```

## II. Scatterplots

### 6. Explore scatterplots using `plot_ly()`

- Create a scatterplot using `plot_ly()` representing `pop_density` vs. various variables (e.g. `cases`, `per100k`, `deaths`, `deathsper100k`) for each state on most recent date (`cv_states_today`)
  - Color points by state and size points by state population
  - Use hover to identify any outliers. 


```{r}
plot_ly(
  cv_states_today,
  x = ~log(pop_density),
  y = ~per100k,
  color = ~state,
  size = ~population,
  type = "scatter",
  sizes = c(5, 100),
  marker = list(sizemode = "diameter", opacity = 0.8)
) |> 
  layout(title = "Cases per 100k vs State Population ")
```

- Remove those outliers and replot.

```{r}
cv_states_today |> 
  filter(
    ! state %in% c(
      "District of Columbia",
      "Alaska",
      "Rhode Island"
    )
  ) |> 
  plot_ly(
    x = ~pop_density,
    y = ~per100k,
    color=~state,
    size = ~ population,
    type = "scatter",
    sizes = c(5, 100),
    marker = list(sizemode = "diameter", opacity = 0.8)
  ) |> layout(title = "Cases vs State Population with outliers removed")
  
```

- Choose one plot. For this plot:
- Add hoverinfo specifying the state name, cases per 100k, and deaths per 100k, similarly to how we did this in the lecture notes
- Add layout information to title the chart and the axes
- Enable `hovermode = "compare"`
  
```{r}
plot_ly(
  cv_states_today,
  x = ~log(pop_density),
  y = ~cases,
  color = ~state,
  size = ~population,
  type = "scatter",
  sizes = c(5, 50),
  marker = list(sizemode = "diameter", 
                opacity = 0.8),
  hoverinfo = "text",
  text = ~ paste0(state, "\n", " Cases per 100k: ", per100k, "\n",
                " Deaths per 100k: ", deathsper100k, "\n",
                " Population density: ", round(pop_density, 1), " per sq miles")
) |> 
  layout(title = "Cumulative Cases vs Log Population Density",
             hovermode = 'x')
```

 
  
### 7. Explore scatterplot trend interactively using `ggplotly()` and `geom_smooth()`

- For `pop_density` vs. `newdeathsper100k` create a chart with the same variables using `gglot_ly()`
- Explore the pattern between $x$ and $y$
- Explain what you see. Do you think `pop_density` correlates with `newdeathsper100k`?

```{r}
plt_smooth <- ggplot(
  cv_states_today, 
  aes(x = pop_density, y = newdeathsper100k)) +
  geom_point(aes(color = state, size = population)) + 
  geom_smooth() +
  theme_minimal() +
  scale_x_continuous(trans = "log") + 
  ylab("new deaths per 100k") + 
  xlab("population density")

ggplotly(plt_smooth)

```

_Comment: I think the population density doesn't correlate with the new deaths per 1000 population because the fitted line seems like a straight flat line. Also, all points follow the general trend, so no special associations._


### 8. Multiple line chart

- Create a line chart of the `naive_CFR` for all states over time using `plot_ly()`
  - Use the zoom and pan tools to inspect the `naive_CFR` for the states that had an increase in September. How have they changed over time?
  
  
```{r}
plot_ly(
  cv_states,
  x = ~ date,
  y = ~ naive_cfr,
  color = ~ state,
  # type = "scatter",
  mode = "line"
) |> 
  layout(hovermode = "x unified")

```

- Create one more line chart, for Florida only, which shows `new_cases` and `new_deaths` together in one plot. Hint: use `add_layer()`

```{r}
cv_states |> 
  filter(state == "Florida") |> 
  plot_ly(
    x = ~date,
    y = ~new_cases,
    type = "scatter",
    mode = "lines"
  ) |> 
  add_lines(
    x = ~ date,
    y = ~ new_deaths)
```

  - Use hoverinfo to "eyeball" the approximate peak of deaths and peak of cases. What is the time delay between the peak of cases and the peak of deaths?
  
  
_Comment: From the plot, there is no time delay between the peak of cases and the peak of deaths. Whenever the cases reach the peak, the deaths reach the peak on the same day as well, such as on 2022-11-04, on 2022-11-18, and so on._


### 9. Heatmaps

Create a heatmap to visualize `new_cases` for each state on each date greater than January 1st, 2023
- Start by mapping selected features in the dataframe into a matrix using the **tidyr** package function `pivot_wider()`, naming the rows and columns, as done in the lecture notes
- Use `plot_ly()` to create a heatmap out of this matrix. Which states stand out?


```{r}
cv_states_mat <- cv_states |> 
  filter(date >= "2023-01-01") |> 
  select(state, date, new_cases) |> 
  pivot_wider(names_from = state, values_from = new_cases) |> 
  column_to_rownames("date")

cv_states_mat |> 
  plot_ly(
    x = rownames(cv_states_mat),
    y = colnames(cv_states_mat),
    z = ~ as.matrix(cv_states_mat),
    type = "heatmap",
    showscale = TRUE
  )

```

_Comment: Colorado, Maine, and Arkansas stand out in the heat map since they have lighter color squares._


- Create a second heatmap in which the pattern of `new_cases` for each state over time becomes more clear by filtering to only look at dates every two weeks.

```{r}
#create heatmap
filter_dates <- seq(
  as.Date("2022-10-01"),
  max_date,
  by = "3 days"
)

new_cv_states_mat <- cv_states |> 
  select(state, date, new_cases) |>  
  filter(date %in% filter_dates) |>  
  pivot_wider(names_from = state, values_from = new_cases) |>  
  column_to_rownames("date")

new_cv_states_mat |>  
  plot_ly(
    x = rownames(new_cv_states_mat),
    y = colnames(new_cv_states_mat),
    z = ~as.matrix(new_cv_states_mat),
    type = "heatmap",
    showscale = TRUE
  )
```

### 10. Map

- Create a map to visualize the `naive_CFR` by state on March 15, 2023

```{r}
pick.date = "2023-03-15"

# Create the map
cv_march_15 <- cv_states |>
  dplyr::filter(date == pick.date)

plot_geo(cv_march_15, 
         locationmode = "USA-states") |>  
  add_trace(
    z = ~naive_cfr,
    locations = ~abb
  ) |>  
  layout(
    geo = list(
      scope = "usa",
      showlakes = TRUE,
      lakecolor = toRGB("darkgray")
    )
  )
```


- Compare with a map visualizing the `naive_CFR` by state on most recent date

```{r}
# Map for today's date

plot_geo(cv_states_today, 
         locationmode = "USA-states") %>% 
  add_trace(
    z = ~naive_cfr,
    locations = ~abb
  ) %>% 
  layout(
    geo = list(
      scope = "usa",
      showlakes = TRUE,
      lakecolor = toRGB("darkgray")
    )
  )
```

